using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Threading;
using UnityEngine.UI;

public class Player : MonoBehaviour
{
    public event Action OnGameOver;

    [Header("My point")]
    public Text XScore; 
    public int Xpontos = 3;
    public GameObject OScore; 
    public int Opontos = 0;

    [Header("Homes")]
    public GameObject[] input;
    public int matrixSize;
    public LayerMask mask;

    [Header("Players")]
    public XorO_Piece X;
    public XorO_Piece O;

    public int turnsCounter;
    public XorO_Piece[,] XO_Pieces;
    public char Winner;

    void Start() // Void Start e chamado no inicio do jogo
    {
        //XScore.GetComponent<Text>().text = Xpontos.ToString();
        OScore.GetComponent<Text>().text = Opontos.ToString();
        XScore.text = Xpontos.ToString();
        //OScore.text = Opontos.ToString();
        XO_Pieces = new XorO_Piece[matrixSize, matrixSize];
    }


    void Update() // Update e para verificar o clique do mouse a cada frame
    {
        
        if (Input.GetKeyDown(KeyCode.Mouse0))
        {
            InstantiateXOs(); 
            if (GameIsOver() && OnGameOver != null)
            {
                OnGameOver();
            }
        }    
    }

    public void InstantiateXOs() // Este metodo percorre toda a matriz do tabuleiro e chama RaycastOperations para cada celula, passando os indices da matriz e um contador.
    {
        int count = 0;
        for (int i = 0; i < matrixSize; i++)
        {
            for (int j = 0; j < matrixSize; j++)
            {
                RaycastOperations(i, j, count);
                count++;
            }
        }
    }

    public void ResetDeparture() // Resetar o tabuleiro
    {
        
        for (int i = 0; i < matrixSize; i++)
        {
            for (int j = 0; j < matrixSize; j++)
            {
                if (XO_Pieces[i, j] != null)
                {
                    Destroy(XO_Pieces[i, j].gameObject);
                }
            }
        }

        turnsCounter = 0;
        Winner = 'N';
        
    }

    public void RaycastOperations(int i, int j, int count) // Este metodo realiza operacoes de Raycast para determinar onde a peca deve ser colocada
    {
        if (Physics.Raycast(new Ray(Camera.main.ScreenToWorldPoint(Input.mousePosition), Vector3.forward), out RaycastHit hitinfo, 100f) && hitinfo.collider.gameObject == input[count])
        {
            if (XO_Pieces[i, j] == null)
            {
                if (turnsCounter % 2 == 0)
                {
                    XorO_Piece p = Instantiate(X, input[count].transform.position, Quaternion.identity);
                    XO_Pieces[i, j] = p;
                }
                else
                {
                    XorO_Piece p = Instantiate(O, input[count].transform.position, Quaternion.identity);
                    XO_Pieces[i, j] = p;
                }
                WhoWins(XO_Pieces[i, j].XorO, new Vector2Int(i, j));
                turnsCounter++;
            }
        }
    }

    public void WhoWins(char xorO, Vector2Int position) // WhoWins verifica se ha um vencedor
    {
        int sum;

        sum = 0;

        for (int i = 0; i < matrixSize; i++)
        {
            XorO_Piece analysePiece = XO_Pieces[i, position.y];
            if (analysePiece != null && analysePiece.XorO == xorO)
            {
                sum += 1;
                
            }
        }

        if (sum == matrixSize)
        {
            Winner = xorO;
            return;
            
        }

        sum = 0;

        for (int i = 0; i < matrixSize; i++)
        {
            XorO_Piece analysePiece = XO_Pieces[position.x, i];
            if (analysePiece != null && analysePiece.XorO == xorO)
            {
                sum += 1;
                
            }
        }

        if (sum == matrixSize)
        {
            Winner = xorO;
            return;
            
        }

        sum = 0;

        for (int i = 0; i < matrixSize; i++)
        {
            XorO_Piece analysePiece = XO_Pieces[i, i];
            if (analysePiece != null && analysePiece.XorO == xorO)
            {
                sum += 1;
               
            }
        }

        if (sum == matrixSize)
        {
            Winner = xorO;
            return;
            
        }

        sum = 0;

        for (int i = 0; i < matrixSize; i++)
        {
            XorO_Piece analysePiece = XO_Pieces[i, (matrixSize - 1) - i];
            if (analysePiece != null && analysePiece.XorO == xorO)
            {
                sum += 1;
                
            }
        }

        if (sum == matrixSize)
        {
            Winner = xorO;
            return;
            
        }
    }

    public void vencedor () // Comparacao dos vencedores
    {
        
        if (Winner == 'X')
        {
            Debug.Log("Parece que o ganhador foi o X");
            Xpontos++;
            
        }
        else if (Winner == 'O')
        {
            Debug.Log("Nosso ganhador foi O");
            Opontos++;
        }
    }


    public bool GameIsOver() // GameIsOver verifica se o jogo terminou
    {
        int matrixSizeSquared = Mathf.RoundToInt(Mathf.Pow(matrixSize, 2));

        int count = 0;
        foreach (XorO_Piece p in XO_Pieces)
        {
            if (p != null)
            {
                count++;
            }
        }

        if (count == matrixSizeSquared || Winner == 'X' || Winner == 'O')
        {
            vencedor();
            StartCoroutine(DelayedReset());

        
            return true;
            
        }
        return false;
    }

    private IEnumerator DelayedReset() // Utilizo para fazer o jogo dar uma esperada de 3 segundos antes de resetar o tabuleiro
    {
        yield return new WaitForSeconds(3f);
        ResetDeparture();
    }
}
